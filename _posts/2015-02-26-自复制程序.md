---
date: 2015-02-26
layout: 'post'
status: 'public'
---

## 自复制程序

冯诺依曼提到过一个完全公理化的自复制自动机的描述体系：

> 假设自动机 X 的符号串是 Φ (X)。接下来，我们可以设计一台通用构造器A ， 当我们把 Φ (X) 喂给 A 的时候，它就能够逐步地利用悬浮在周围的零件，把 X 一点点的组合出来。实际设计工作当然是很麻烦的，但是理论上却是可以办到的。 因为这个过程可以归纳为形式逻辑的分步推理，从性质上说， 这和通用图灵机并无区别。

> 还有一件事要说， 我之前提到过，要制造一台能够直接复制任何自动机的机器是比较复杂的。 所以最好是从要复制的机器的描述而不是从机器的实体来进行复制。 但是我想补充一点， 存在着某复制机器可以直接拷贝线性的刚体零件链，这是很简单的。 因为导致实体复制困难的真正原因是， 实体自动机的结构同我们串行的思考习惯完全不同， 各种各样的零件朝着各个方向相互连接。 仅仅是把已经扫描过的零件排除在列表外，便是很麻烦的事情。 但是拷贝一根长链并无这种困难。所以， 我可以假设存在一台通用拷贝机器 B，当我们把任何描述输入 B 的时候， B 就会制造出同样的两份描述出来。

> 在完成以上两步之后， 可能给人一种错觉，在此过程中复杂度衰退的原理似乎仍然没被打破。 在表面上看， 似乎在复制过程中， 既没有产生更微妙的东西， 也没有建立更多的联系。 A 只能按照描述来制造 X 。而按照对于复杂度的一般认识， X 的复杂度是和 X 的描述相等的。另一方面， B 拷贝得到了两份 Φ (X) ， 但是两个同样的事物放在一起，没有理由说它们作为整体的复杂度要高于其中一个的复杂度，并且， 我们还需要额外的机器 B 来完成复制。但实际上并不是这样的。

> 现在我们可以做下面这件事，我们可以把机器 A 和 B 组合在一起， 并给 A+B 添加一个控制器 C 。 C 按照下列方式对 A 和 B 施加控制： C 先命令 B 拷贝两份描述 Φ (X) ； 然后再命令 A 按照 Φ (X) 来实际制造 X ， 并把其中的 1 份 Φ (X) 拷贝去掉； 最后， C 会把 X 和剩下的那份 Φ (X) 捆在一起， 并把它们从机器 A+B+C 的组合中间分离出去，这样一来，我们就制造出了 X+ Φ (X) 这样的组合。 按照以上原理，如果我们用（ A+B+C ）来代替 X ， 并进行上述同样的操作的话，那么 
> (A+B+C)+ Φ (A+B+C) 的自动机组合， 就可以制造出自动机组合： (A+B+C)+ Φ (A+B+C) 出来。因此， 自动机自复制得到了实现！

> 这个过程的细节如下：

> 1 、 现有自动机 (A+B+C) ， 并附有它的描述 Φ (A+B+C) 。 

> 2 、 从 (A+B+C)+ Φ (A+B+C) 开始复制流程。 

> 3 、 C 控制 B 拷贝两份描述， 得到： (A+B+C)+ Φ (A+B+C)+ Φ (A+B+C) 。 

> 4 、 C 命令 A 按照 Φ (A+B+C)) 来实际制造出 A+B+C ，得到 (A+B+C)+( A+B+C)+ Φ (A+B+C)+ Φ (A+B+C) 。 

> 5 、 最后 C 把新得到的自动机 A+B+C 和它的描述 Φ (A+B+C) 捆在一块， 并把自己和新自动机分开，这就得到 2 个 (A+B+C)+ Φ (A+B+C) ；复制完成。

> 这个过程并不是循环论证： 我首先把 A 和 B 做了清楚的定义。 在我提到 X 之前， 我已经说明， C 可以适用于任何形式的自动机 X 。 接下来定义了一个变量 X ， 它描述了 C 将要怎么做， 然后，我再让这个变量 X 和 C 产生联系。 所以， A 、 B 和 C 的定义是完全独立于 X 的， 在此之后， 我再让这个 X 指代 A 、 B 或者 C 。 因此， 整个过程并非循环。

> 以上的通用构造器A 具有一定意义上的创造力，也就是说， A 可以从抽象的描述来“制造”出实体的机器来。同样的， 通用拷贝机 B 也有一种能够把一份描述变成两份的“创造能力”。但 A 和 B 都不具备自复制能力， 此外， 控制器 C 也远远没有具备任何形式的创造或复制能力， 它唯一能做的就是刺激其它的两个组件去做一
> 些事情， 把一些东西连接在一起， 或者把一些东西从原来的系统中分割出去。 然而， 一旦 A 、 B 和 C 组合在一起， 它们作为一个整体却能够复制自身。故而我们可以把一个自复制系统分割成不同的部分， 每一个部分虽然都不能够复制自身， 但对于自复制机器整体却又都是必不少的。

> 我们还可以做另外一件事， 让 X 代表 A+B+C+D ， 这里 D 代表任何自动机。那么 (A+B+C)+ 
> Φ (A+B+C+D) 就可以制造出 (A+B+C+D)+ Φ (A+B+C+D) 。 换句话说， 我们的自复制机器不仅
> 仅有复制自己的能力，还可以顺便生产出其他的组件 D 的能力。这就是任何自复制生命都
> 具备的功能：在复制自身的时候，它还会创造出副产品。

> 作为一个系统， (A+B+C+D) 可以发生类似变异的过程。在定义“自复制” 究竟是什么意思的时候， 我们会遇到这样的困难：有些结构， 比如晶体的生长的确也是在复制自己。 但是我们都觉得把晶体称为自复制， 显然是名不副实的。 有一个办法可以绕过这个困难， 就是把发生变异的能力， 以及制造类似却不等同于母体的生命的能力包括在“自复制” 的定义中间。

> 现在考虑 (A+B+C+D)+ Φ (A+B+C+D) 这个自动机。“变异”是指中间有一个零件发生随机的变化。如果是 A 、 B 或者 C 的一个零件发生了变化， 那么系统通常就会失去自复制的能力。比如 C 的一个零件被修改以后， C 很可能就不能在正确的时间上给 A 和 B 发射刺激信号， 或者无法在需要的时候进行连接和分割，这样的变异就是致命的。

> 但是如果变异发生在描述 Φ (A+B+C+D) 上面， 那么系统制造出的就不再是它自己，而是修改后的自己，下一代自动机能否继续复制取决于变异发生的具体位置。 如果 A 、 B 或者 C 发生了变化， 那么子代自动机就会“绝后”。但是如果变异发生在 D 的描述上， 那么除了 D 变成了 D’ 之外， 变异的子代同母体系统完全相同。 之后的子代会把这个变异 D’ 继承下去。这就是可遗传变异的基本过程。

> 总之， 虽然这套系统还非常原始，但它已经具备了可遗传变异的基本特性。 大多数随机变异都是致命的， 但是也可能偶尔会发生非致命乃至是可遗传的变异。 这是遗传所特有的性质，这套系统也同样具备了。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

JAKE描述了一个自复制程序的实现，实际上是一个能够把自己源码打印出来的程序：

S (x){ 
q=’S(x){\\n q=\\\’\’+q+\’\\\’;\\n Print(\\\’\’+p(q)+\’\\\’);\\n}’; 
Print (‘S(x){\n q=\’’+q+’ \’;\n Print(\’’+p(q)+’\’);\n}’); 
} 

这里面的“ \n ” 表示换行符，即如果执行 Print(‘A\nB’) ，则程序会输出下面的字符串： 
A 
B 
“ + ” 表示将两个字符串进行串联形成一个新的字符串，例如 A=’123’,B=’456’ ，则 A+B=’123456’ 。

这个自打印程序调用了一个简单的解码函数 p(q) ， p 的作用是将字符串 q 变换成更浅一层次的字符串。 例如，如果 q 是“ \\\’\’\\n\\ ” ， 那么 p 这个函数就会计算输出 “ \’’\n\ ” 。也就是说 p 完成了一组映射： 它把“ \\ ”映射成“ \ ”，把“ \’ ”映射成“ ’ ”，而把“ \n ”映射成回车符。显然 p 是可以写出来的。 大家可以利用 java 或者 VB 来实现这个程序，运行它就会发现它能够自我复制。

让我们来分析一下这个程序是如何运作的。 首先， 看程序的最后一行， 即 Print (‘S(x){\n q=\’’+q+’ \’;\n Print(\’’+p(q)+’\’);\n}’); 这句话的作用是让程序在屏幕上打印出一个字符串 。 注意观察， 这个被打印出的字符串其实是由“ + ”号被分割成了 5 个部分， 第一部分是“ S(x){\n q=\’ ”， 第二个部分是 q 这个字符串的原封不动的拷贝，第三部分是字符串：“ \’;\n Print(\’ ”，第四部分是函数 p 作用到 q 上面的结果即 p(q) ；第五部分还是一个字符串：“ \’);\n} ”。 然后当我们把 q 字符串的数值代入第二部分和第四部分，并进行运算 p 之后，就得到了和源程序一模一样的结果。 你不妨在计算机上运行这段程序， 就会发现这段程序会在屏幕上赤裸裸地把自己的源代码打印出来。

我们不妨把这段程序的 5 个部分进行归并，写成由下面的三部分构成的： Copy о Popup о Control ， 其中 Copy 就是 5 部分中的第二部分， 即相当于一个拷贝字符串的程序，你输入给 Copy 什么字符串， Copy 就会把那个字符串再原封不动地吐出来； Popup 这部分就是原来的 5 部分中的第四部分，即函数 p ， 它的作用相当于一个弹出操作， 也就是为输入的字符串脱去一层引号。如果输入的字符串原来是在第 n 层虚拟世界，则 Popup 的作用就是让字符串跳到第 n-1 层； 最后 Control 这部分就相当于原来的第 1 、 3 、 5 这三部分以及最一开始的语句 Print 的总合，它的作用就相当于是为 Copy 和 Popup 制造出来的字符添加适当的连接词，使得最后的字符串能够拼接成与原来的程序一模一样的源程序， 并将其打印到屏幕上。所以这句“ Print (‘S(x){\n q=\’’+q+’ \’;\n Print(\’’+p(q)+’\’);\n}’); ” 就可以改写成 (Copy о Popup о Control)(q) 。 其中“ о ” 表示将不同的程序连接为一体。

如果我们把一个计算机程序 X 的描述（或者称源代码）写为 Φ ( X) ， 则自打印程序的第一条赋值语句就相当于给 q 赋予了 Φ ( (Copy о Popup о Control)) ，即 (Copy о Popup о Control) 这三个程序连在一起的源代码。 最后我们可以将自打印程序简写为：

S(x){ 
q= Φ (Copy о Popup о Control) 
(Copy о Popup о Control) (q); 
} 
那么， 观察这个程序，就会发现实际上它就是冯纽曼所说的那个自复制程序： (A+B+C)+ Φ (A+B+C) 了。在这里 Copy 就相当于冯纽曼程序中的拷贝器 B ， 它能将输给它的数据原封 不断地再打印出来； Popup 就相当于冯纽曼说的通用构造器，它能够根据一段数据而把数据对应的自动机的源代码打印出来（这相当于从描述中构造出自动机）。 Control 这部份就对应了 C 。而 q= Φ (Copy о Popup о Control) 就对应了描述： Φ (A+B+C) 。 因此， 我们实际上可以很容易地用我们的个人电脑实现自复制的计算机程序。

摘自“复杂自动机的一些考量”---JAKE

​~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

关于这个“自复制”程序的几个问题：

1、  程序最关键的部分是转义字符“/”和解码函数p(q)的使用。转义字符的使用，实际上可以看做是对程序语言的一种描述，也就是起到Φ (A+B+C)的作用。而p(q)则是对这种描述的解释过程，相当于构造器A的作用（整个构造过程还包括打印的过程）。

2、  在这个程序中，A、B、C的体现比较混乱，不能进行明显的区分。以下是用C#实现的同样功能的程序，这个程序将A、B、C的功能显示的区分了出来，从中可以比较清楚的看出程序实现本质的一些端倪：
​```
namespace SelfCopy{

    class Program {

        static void Main(string[] args){

            Control();

        }

        static void Control(){

            Generate(Copy(deGenerate()));

        }

        static string Copy(string G){

            return G;

        }

        static void Generate(string gene){

            StreamWriter sw = new StreamWriter("ProCopy.cs");

            sw.Write(gene);

            sw.Close();

        }

        static string deGenerate(){

            StreamReader sr = new StreamReader("E:\\vs_proj\\SelfCopy\\SelfCopy\\Program.cs");

            string G = sr.ReadToEnd();

            sr.Close();

            return G;

        }

    }

}
​```
程序中`deGenerate()`的作用相当于Φ，`Generate()`相当于通用构造器A，`Copy()`相当于复制器B，`Control()`相当于控制器C。C实际上是一个描述程序怎样运行的逻辑过程，而C本身又包含在程序中，程序执行的过程实际上就是C执行的过程（见`Main()`）。

3、  与最初的程序不同的地方在于，这个程序并没有用到转义字符，而是直接引用了程序的源文件作为它的一个描述。这就导致了程序实际上引用了一个外部文件，这个外部文件也应该成为程序的一个必不可少的部分。实际上，程序不仅引用了这个外部文件，还引用了类似`printf，StreamWriter，StreamReader`等这些外部函数和外部类。对于这种外部引用，网络上争论不休，一个意见是认为，如果引入了外部的信息则不能算是真正意义上的自复制；另一个意见是认为，并不影响自复制整个逻辑思想的正确性，也就是说这只是程序上的一种简化和技巧，不用这些也可以用同样的方法构造出可以复制自身的程序来。这两种意见都没有抓住问题的核心。如果对比一下上述两个程序，就可以看出，前一程序转义字符的引入和后一程序外部文件的引入本质上是一样的，都是得到一个对程序的字符化描述。如果把引入的外部文件，用字符显示的话，也必然要用到转义字符，外部文件内实际上也就是这些字符的集合，我们之所以能够通过打开这个文件直观的看到里面的内容是因为打开文件的程序对字符进行了格式化的处理，并且显示到了屏幕上，也就是说，我们所看到的外部文件的样子并不等同于他实际的样子，它实际的样子可能是一些二进制的串，而我们看到和理解的是字母和单词。这是描述和表现形式之间的转换，后一个程序如果不引用外部的文件，完全也可以像前一个程序一样，将该文件（程序）内容用字符的形式嵌入程序中。而整个程序也就是讲这些字符格式化显示到屏幕的过程。（从这个意义上来说，后一个程序并没有将其显示到屏幕的过程，而是直接又放进了文件中，也就是并没有将描述转换为表示，这种转换实际上是在我们打开这个文件的时候进行的。）有了这个认识，那么关于引用外部程序或函数的问题也就有了答案，即只要将所有被引用的函数和程序统统包含到这个文件中就可以了。

4、  这种所谓的“自复制”程序并没有真正意义上的自我复制，有人将其叫做“自打印”程序，其实也不确切。我觉得，这个程序并没有实现自我复制的原因在于，他复制的还只是程序描述，而不是程序本身。程序本身是进过编译等过程后能够运行在电脑上的二进制数据集合，而这个程序复制出来的文件并不能直接执行。但这也不是问题的根本所在，因为程序完全可以设计为将生成出来的可执行文件直接复制一次的形式。这是一种暴力式的复制，如果如冯诺依曼所说，“要制造一台能够直接复制任何自动机的机器是比较复杂的。所以最好是从要复制的机器的描述而不是从机器的实体来进行复制”，而程序的这种直接的暴力的复制好像说明程序本身即是他的描述，直接的复制并不一定比对描述的复制来的更加的复杂。这是因为冯诺依曼所提出的问题是在具体和抽象两个层次上，而程序的复制则都处于抽象的层次。程序的复制对机器本身并不做任何限制或要求。问题在于，虽然所处的层面不同，但程序的这种能力与现实世界中的自复制能力有没有一些共同的地方。要解决这个问题，必须要解释，为什么非要通过一次描述来复制自身，而不是直接的复制。冯诺依曼，并没有对此给出答案。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
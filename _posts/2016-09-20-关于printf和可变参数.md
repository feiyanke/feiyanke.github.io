---
date: 2016-09-20
layout: 'post'
tags:
    - 'c'
status: 'public'
---

# 关于printf和可变参数

问题是从一段代码开始的：
```c
uint8_t a = -1;
uint32_t b = -1;
printf("%d,%d", a, b);
```
这段代码实际输出是：`255,-1`，为什么同样是无符号数，同样是`%d`，`uint8_t`和`uint32_t`会出现不一样的结果呢？

我首先想到的是，`printf`接受的是可变参数，其原型为：
```c
int printf(const char * _Format,...);
```
也就是说在`printf`函数内部，实际上是不知道传入的参数的类型的，那么只能通过格式化字符串内的标识来判断当前参数的类型，那么这个标识应该是会有符号和无符号的区别的，否则无法区分有符号数和无符号数。
果然，有一个`%u`的标志是代表无符号数的，于是代码改为：

```c
uint8_t a = -1;
uint32_t b = -1;
printf("%u,%u", a, b);
```
结果现在输出为：`4294967295,4294967295`。问题又来了，`uint8_t`的打印结果应该是`255`，为什么是`4294967295`呢？

其实，按照刚才的思路，`printf`并不知道输入的参数是多少位的，只能通过格式化字符串来判断参数的类型和位数。实际上，格式化标识中确实有代表参数位数的标识：`hh,h,l,ll`，分别代表是`char,short,long,long long`，于是代码改为：

```c
uint8_t a = -1;
uint32_t b = -1;
printf("%hhu,%u", a, b);
```
其输出为：`255,4294967295`，终于符合预期了。然而，事情还没有结束。我想到c语言函数调用时参数时顺序入栈的，既然`%u`代表是取`uint32_t`的长度的数据，那个在上一个代码段，输出`a`的时候就在栈上取了4个字节，在输出`b`的时候如果再取4个字节，岂不是就溢出了吗？也许是巧合，将代码改为：
```c
int8_t a = -1;
int32_t b = -200;
printf("%d,%d", a, b);
```
程序正确输出：`-1,-200`，并没有出现溢出的情况，这是为什么呢？

查阅C99标准后，才发现可变参数的传递，遵循所谓的`default argument promotion`。

c语言中，使用可变参数一般需要用到几个宏：`va_list,va_start,va_arg,va_end`：

```c
void test(char a, ...)
{
    va_list ap;
    va_start(ap,a);
    uint32_t v1 = va_arg(ap, uint32_t);
    ...
    va_end(ap);
    ...
}
```
在这个过程中，是通过`va_arg`来获取相应类型的参数，`va_arg`的原型为：

```c
type va_arg(va_list ap, type);
```
但是实际使用中，`type`只能用4字节或8字节的类型，比如`int,double`，如果使用其他类型例如`char,short`等，在某些编译器中会导致运行时错误，在某些编译器中会对齐到4字节。这些都是由于，在可变参数的传递过程中的`default argument promotion`，具体来说就是，无符号的整形都扩展为`uint32_t`，有符号的整形均扩展为`int32_t`，浮点型均扩展为`double`。

这些是C99标准行为，标准中也说明，在可变参数的使用中，需要保证取参数的类型要符合传入参数的类型定义，否则会导致未定义的行为.








